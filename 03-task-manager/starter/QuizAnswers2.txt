In this lesson, you created a middleware function called asyncWrapper. Why?
Handling errors in asynchronous code can be complex due to the nature of promises or async/await. AsyncWrapper encapsulates this complexity by catching any errors that occur in the asynchronous
function fn and passing them to Express.js error handling middleware.

Suppose that you want to make sure that both a status code and an error message are sent back to the user when they request the URL for a task that does not exist. Assume that youâ€™ve created a CustomAPIError class and an error handler that references that class. Complete the code:
const getTask = asyncWrapper(async (req, res, next) => {
  const { id: taskID } = req.params;
  const task = await Task.findOne({ _id: taskID });
  if (!task) {
    return next(createCustomError(`Task with id : ${taskID} not found`, 404));
  }
  res.status(200).json({ task });
});